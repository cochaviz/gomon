package cmd

import (
	"errors"
	"fmt"
	"io/fs"
	"log/slog"
	"os"
	"path/filepath"
	"runtime/debug"
	"strings"
	"time"

	"github.com/google/gopacket/pcap"
	"github.com/spf13/cobra"

	"github.com/cochaviz/gomon/internal"
)

const asciiBanner = `
     _______    ______   ___ __ __   ______   ___   __
    /______/\  /_____/\ /__//_//_/\ /_____/\ /__/\ /__/\
    \::::__\/__\:::_ \ \\::\| \| \ \\:::_ \ \\::\_\\  \ \
     \:\ /____/\\:\ \ \ \\:.      \ \\:\ \ \ \\:.  -\  \ \
      \:\\_  _\/ \:\ \ \ \\:.\-/\  \ \\:\ \ \ \\:. _    \ \
       \:\_\ \ \  \:\_\ \ \\. \  \  \ \\:\_\ \ \\. \ -\  \ \
        \_____\/   \_____\/ \__\/ \__\/ \_____\/ \__\/ \__\/`

const (
	defaultWindowSizeS           = 30
	defaultPacketRateThresh      = 5.0
	defaultDestinationRateThresh = 10.0
	defaultScanDetectionMode     = "filtered-host-rate"
	defaultLogLevel              = "info"
)

var (
	packetRateThreshold      = defaultPacketRateThresh
	destinationRateThreshold = defaultDestinationRateThresh
	scanDetectionMode        = defaultScanDetectionMode
	logLevelStr              = defaultLogLevel
	windowSizeSeconds        = defaultWindowSizeS
	captureDirPath           string
	showIdle                 bool
	c2IP                     string
	sampleID                 string
	ignoreDestIPs            []string
	eveLogPath               string
	savePacketsCount         int
	showVersionOnly          bool
	calibrate                bool
)

var version = resolveVersion()

func init() {
	RootCmd.SetVersionTemplate("gomon version {{.Version}}\n")
	RootCmd.Version = version
	RootCmd.Flags().Float64Var(
		&packetRateThreshold,
		"packet-threshold",
		defaultPacketRateThresh,
		"Packet rate threshold per window before marking traffic as suspicious.",
	)
	RootCmd.Flags().Float64Var(
		&destinationRateThreshold,
		"destination-threshold",
		defaultDestinationRateThresh,
		"Unique destination host (IP only) threshold per window before flagging a horizontal scan.",
	)
	RootCmd.Flags().StringVar(
		&scanDetectionMode,
		"scan-detection-mode",
		defaultScanDetectionMode,
		"Scan detection mode: host-rate, new-host-rate, or filtered-host-rate.",
	)
	RootCmd.Flags().StringVar(
		&scanDetectionMode,
		"destination-rate-mode",
		defaultScanDetectionMode,
		"Deprecated: use --scan-detection-mode.",
	)
	_ = RootCmd.Flags().MarkDeprecated(
		"destination-rate-mode",
		"use --scan-detection-mode",
	)
	RootCmd.Flags().StringVar(
		&logLevelStr,
		"log-level",
		logLevelStr,
		"Logging level (debug, info, warn, error).",
	)
	RootCmd.Flags().IntVar(
		&windowSizeSeconds,
		"window",
		defaultWindowSizeS,
		"Analysis window size in seconds.",
	)
	RootCmd.Flags().StringVar(
		&c2IP,
		"c2-ip",
		"",
		"Command-and-control IP address associated with the traffic (optional).",
	)
	RootCmd.Flags().StringVar(
		&sampleID,
		"sample-id",
		"",
		"Identifier used to correlate analysis results to a specific sample (optional).",
	)
	RootCmd.Flags().StringSliceVar(
		&ignoreDestIPs,
		"ignore-dst",
		nil,
		"Destination IP addresses to skip when computing metrics (repeatable).",
	)
	RootCmd.Flags().StringVar(
		&eveLogPath,
		"eve-log-path",
		"",
		"Optional file path for Eve JSON output (stdout if omitted).",
	)
	RootCmd.Flags().BoolVar(
		&showIdle,
		"show-idle",
		false,
		"Emit idle window events (disabled by default).",
	)
	RootCmd.Flags().StringVar(
		&captureDirPath,
		"capture-dir",
		"",
		"Directory for packet capture artifacts (default: ./captures).",
	)
	RootCmd.Flags().IntVar(
		&savePacketsCount,
		"save-packets",
		0,
		"Number of most recent packets per host to retain for capture artifacts when an attack is detected.",
	)
	RootCmd.Flags().BoolVar(
		&showVersionOnly,
		"version",
		false,
		"Print the gomon version and exit.",
	)
	RootCmd.Flags().BoolVar(
		&calibrate,
		"calibrate",
		false,
		"Log calibration metrics without emitting classification events.",
	)
}

var RootCmd = &cobra.Command{
	Use:   "gomon <input> <src_ip>",
	Short: "Detect interesting network events for sandboxed bots.",
	Long: `gomon ingests live traffic or PCAP captures generated by sandboxed bots and
identifies time windows that exceed packet-rate or destination host thresholds. The tool logs
structured alerts that highlight horizontal scans or bursts of suspicious activity.`,
	Example: "gomon sample.pcap 10.0.0.5 --window 15 --packet-threshold 20 --log-level info --c2-ip 203.0.113.4 --ignore-dst 192.0.2.10 --sample-id malware-sample-42",
	Args:    cobra.ExactArgs(2),
	PersistentPreRun: func(cmd *cobra.Command, args []string) {
		if showVersionOnly {
			cmd.Printf("gomon version %s\n", version)
			os.Exit(0)
		}
		cmd.Println(asciiBanner)
		cmd.Println()
		cmd.Print(renderRuntimeConfiguration(args))
	},
	RunE: executeAnalysis,
}

func executeAnalysis(cmd *cobra.Command, args []string) error {
	input := args[0]
	srcIP := args[1]

	if eveLogPath != "" {
		if err := ensureOutputDir(filepath.Dir(eveLogPath)); err != nil {
			return err
		}
	}

	if packetRateThreshold <= 0 {
		return fmt.Errorf("packet-threshold must be greater than 0, received %f", packetRateThreshold)
	}
	if destinationRateThreshold < 0 {
		return fmt.Errorf("destination-threshold must be non-negative, received %f", destinationRateThreshold)
	}
	if windowSizeSeconds <= 0 {
		return fmt.Errorf("window must be greater than 0, received %d", windowSizeSeconds)
	}
	if captureDirPath == "" {
		captureDirPath = filepath.Join(".", "captures")
	} else if err := ensureOutputDir(captureDirPath); err != nil {
		return err
	}

	level, err := parseLogLevel(logLevelStr)
	if err != nil {
		return err
	}

	scanMode, err := internal.ParseScanDetectionMode(scanDetectionMode)
	if err != nil {
		return err
	}

	handle, err := resolveHandle(input)
	if err != nil {
		return err
	}

	config := internal.NewAnalysisConfiguration(
		srcIP,
		c2IP,
		ignoreDestIPs,
		showIdle,
		time.Duration(windowSizeSeconds)*time.Second,
		eveLogPath,
		packetRateThreshold,
		destinationRateThreshold,
		scanMode,
		level,
		sampleID,
		calibrate,
		savePacketsCount,
		captureDirPath,
		nil,
	)
	defer func() {
		if err := config.Close(); err != nil {
			cmd.PrintErrf("warning: unable to close log file: %v\n", err)
		}
	}()

	if err := internal.CaptureLoop(handle, config); err != nil {
		return fmt.Errorf("capture loop failed: %w", err)
	}

	if calibrate {
		summary := config.CalibrationSummary()
		cmd.Println("Calibration complete. Alerts suppressed; see logs for per-window metrics.")
		if summary.Windows == 0 {
			cmd.Println("Calibration summary: no complete windows were processed.")
			return nil
		}
		cmd.Printf("Calibration summary: %d window(s) analyzed\n", summary.Windows)
		cmd.Printf(
			"Recommended thresholds (based on max observed rates): packet-threshold >= %.4f, destination-threshold >= %.4f\n",
			summary.RecommendedPacketThreshold,
			summary.RecommendedDestinationThreshold,
		)
		if summary.MaxDestinationRate > 0 && summary.MaxDestination.IP != "" {
			cmd.Printf(
				"Top destination: %s (rate %.4f packets/s, %d packets)\n",
				summary.MaxDestination.String(),
				summary.MaxDestinationRate,
				summary.MaxDestinationPackets,
			)
		}
		return nil
	}

	summary := config.Summary()

	if eveLogPath != "" {
		cmd.Printf("Analysis complete. Eve log: %s\n", filepath.Clean(eveLogPath))
	} else {
		cmd.Println("Analysis complete. Eve log: stdout")
	}
	cmd.Printf(
		"Summary: %d attack alert(s), %d scan alert(s), %d idle window(s), %d capture(s) saved\n",
		summary.AttackEvents,
		summary.ScanEvents,
		summary.IdleEvents,
		summary.SavedCaptures,
	)
	return nil
}

func parseLogLevel(level string) (slog.Level, error) {
	switch strings.ToLower(level) {
	case "debug":
		return slog.LevelDebug, nil
	case "info":
		return slog.LevelInfo, nil
	case "warn", "warning":
		return slog.LevelWarn, nil
	case "error", "err":
		return slog.LevelError, nil
	default:
		return slog.LevelInfo, fmt.Errorf("unsupported log-level %q (expected debug, info, warn, error)", level)
	}
}

func resolveHandle(input string) (*pcap.Handle, error) {
	isPCAP := strings.HasSuffix(strings.ToLower(input), ".pcap")
	if isPCAP {
		return HandleFromFile(input)
	}

	info, err := os.Stat(input)
	if err == nil {
		if info.IsDir() {
			return nil, fmt.Errorf("input %q is a directory; expected file or interface", input)
		}
		return HandleFromFile(input)
	}

	if !errors.Is(err, fs.ErrNotExist) {
		return nil, fmt.Errorf("unable to inspect %q: %w", input, err)
	}

	return HandleFromInterface(input)
}

func ensureOutputDir(dirPath string) error {
	if dirPath == "" {
		return nil
	}

	info, err := os.Stat(dirPath)
	if err == nil {
		if !info.IsDir() {
			return fmt.Errorf("output path %q is not a directory", dirPath)
		}
		return nil
	}

	if errors.Is(err, fs.ErrNotExist) {
		// Create the directory tree so subsequent steps can use it.
		if mkErr := os.MkdirAll(dirPath, 0o755); mkErr != nil {
			return fmt.Errorf("unable to create output directory %q: %w", dirPath, mkErr)
		}
		return nil
	}

	return fmt.Errorf("unable to access output directory %q: %w", dirPath, err)
}

func renderRuntimeConfiguration(args []string) string {
	const placeholder = "<unset>"

	var inputArg, srcArg string
	if len(args) > 0 {
		inputArg = args[0]
	} else {
		inputArg = placeholder
	}
	if len(args) > 1 {
		srcArg = args[1]
	} else {
		srcArg = placeholder
	}

	window := (time.Duration(windowSizeSeconds) * time.Second).String()

	captureDir := captureDirPath
	if captureDir == "" {
		captureDir = filepath.Join(".", "captures")
	}
	captureDir = filepath.Clean(captureDir)

	eveDestination := "stdout"
	if eveLogPath != "" {
		eveDestination = filepath.Clean(eveLogPath)
	}

	var ignoredDest string
	switch len(ignoreDestIPs) {
	case 0:
		ignoredDest = "<none>"
	default:
		ignoredDest = strings.Join(ignoreDestIPs, ", ")
	}

	c2Display := c2IP
	if c2Display == "" {
		c2Display = "<none>"
	}
	sampleDisplay := sampleID
	if sampleDisplay == "" {
		sampleDisplay = "<none>"
	}

	var b strings.Builder
	b.WriteString("Configuration:\n")
	fmt.Fprintf(&b, "  version: %s\n", version)
	fmt.Fprintf(&b, "  input: %s\n", inputArg)
	fmt.Fprintf(&b, "  source-ip: %s\n", srcArg)
	fmt.Fprintf(&b, "  window: %s\n", window)
	fmt.Fprintf(&b, "  packet-threshold: %.2f\n", packetRateThreshold)
	fmt.Fprintf(&b, "  destination-threshold: %.2f\n", destinationRateThreshold)
	fmt.Fprintf(&b, "  scan-detection-mode: %s\n", scanDetectionMode)
	fmt.Fprintf(&b, "  log-level: %s\n", logLevelStr)
	fmt.Fprintf(&b, "  show-idle: %t\n", showIdle)
	fmt.Fprintf(&b, "  calibrate: %t\n", calibrate)
	fmt.Fprintf(&b, "  c2-ip: %s\n", c2Display)
	fmt.Fprintf(&b, "  sample-id: %s\n", sampleDisplay)
	fmt.Fprintf(&b, "  ignore-dst: %s\n", ignoredDest)
	fmt.Fprintf(&b, "  save-packets: %d\n", savePacketsCount)
	fmt.Fprintf(&b, "  capture-dir: %s\n", captureDir)
	fmt.Fprintf(&b, "  eve-log-path: %s\n", eveDestination)

	return b.String()
}

func resolveVersion() string {
	const fallback = "dev"

	v := fallback
	if info, ok := debug.ReadBuildInfo(); ok {
		if info.Main.Version != "" && info.Main.Version != "(devel)" {
			v = info.Main.Version
		} else if rev := lookupBuildSetting(info.Settings, "vcs.revision"); rev != "" {
			if len(rev) > 7 {
				rev = rev[:7]
			}
			v = fmt.Sprintf("%s (%s)", fallback, rev)
		}
	}
	return v
}

func lookupBuildSetting(settings []debug.BuildSetting, key string) string {
	for _, setting := range settings {
		if setting.Key == key {
			return setting.Value
		}
	}
	return ""
}
